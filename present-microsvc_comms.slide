Microservice Communications
Comparing net/rpc, message bus, REST and gRPC
12 Nov 2017

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

* Monolith
- Program implemented within a single process

.play -edit mono/main.go

- Nothing wrong with monoliths. However to update anything, you have to shutdown the entire system / program.

* Remote Procedure Call


* net/rpc from Go standard library
- First define a package to hold type and service definitions
- I have chosen the package name nrpc and vendored it in ./vendor
- It is accessed as "siuyin/present-microsvc_comms/nrpc"

.code nrpc/nrpc.go

* Server
- The server imports the nrpc package
- Implements Arith.Sum service

.play nrpc/server/main.go /010/,/020/

- Let's run the server.

* Client
- The client also imports the nrpc package
- Calls the service

.play -edit nrpc/client/main.go /010/,/020/

* What was gained in creating the Arith service?
- Well defined responsibilities: Client responsible for UI and Server for computation.
- Servers can be updated without changing Client code and vice-versa.

We have well defined separation of concerns.

---

- One Server can serve many clients (when computation is cheap).
- Many Servers can be deployed to serve clients (when computation is expensive)
We gain independent scalability.


* The costs are:

- additional complexity
- network latency
- multiple servers must be served behind a load balancer
- with go net/rpc both Server and Client must be written in Go (gob serialization)
- Servers and Clients are still tightly coupled via RPC


* Message Bus


* Message Bus: Concept
- Clients send messages to a message bus
- Servers listen for relevant messages on message bus subjects or topics
- Servers reply with answers to the message bus
- Clients pickup replies from the message bus

* Start a message bus
- I will use the NATS message bus 
- Download and install the gnatsd binary to a folder on your path
.link http://nats.io/

.play nats_start.sh

* Define message types and message bus subjects / topics
- Package mbus accessible as "siuyin/present-microsvc_comms/mbus"

.code mbus/mbus.go


* Server
- go get github.com/nats-io/go-nats

.play  mbus/server/main.go /010/,/020/

* Some NATS detail
.code mbus/server/main.go /030/,/040/

- with the NATS (json) encoded connection
- subscribe to the mbus.ArithSum subject
- handle messages with the function that receives as parameters
- subj -- the NATS subject
- reply -- the NATS topic (subject) to send replies to
- args -- input arguments

Let's run the server (back one screen / run).

* Client

.play -edit mbus/client/main.go /010/,/020/

* Message bus vs go net/rpc
- NATS allows any encoding: JSON, gob, protocol buffers etc. JSON and gob are built-in.
- NATS RequestWithContext allows for explicit cancellation or timeouts.
- Message bus servers and clients can be written in different languages (eg. go and python)
- Message bus components can be type safe if type definition file is used (eg. mbus package)
- However mbus package is specific to go. It has to be manually ported to other languages.
- Message bus components need not use shared type definition file, type safety is lost but flexibility gained.
- Message bus allows Pub/Sub. RPC does not.

Hence message bus components *can* be less tightly coupled than RPC.
Allows for faster development at the cost of type safety and bugs.


* REST (REpresentational State Transfer)


* Server
- The heart of the server is *sumStr*

.play rest/server/main.go /010/,/020/

- Let's see what *sumStr* does.

* Proceesing query parameters
.code rest/server/main.go /030/,/040/

Now run the REST server (back one screen / run).


* Client
- We must URL encode our parameters

.play -edit rest/client/main.go /010/,/020/

* Message bus vs REST 
- NATS message bus is lighter-weight than http / REST
- ZeroMQ (1 million messages / sec), NATS (100,000 m/s), REST (10,000 m/s)
- Message bus service args are directly (JSON/GOB) encoded rather than URL encoded (parsing overhead)
- Message bus requires a message broker (NATS) or library (ZeroMQ, akka etc). 
- REST servers may often use embedded http server.


* gRPC

* Why use gRPC?
- Supports many languages, Go, Ruby, Java, Python, C#, C++ etc.
- Generates stubs in the above languages from a .proto interface definition file.
- Uses binary protocol buffer serialization over http/2 transport for efficiency
- Supports bi-directional streaming over one multiplexed connection
- golang context support allows for explicit cancellation and/or timeouts

* gRPC setup on development workstation
- go get google.golang.org/grpc
- download and install *protoc* from https://github.com/google/protobuf/releases
- go get -u github.com/golang/protobuf/protoc-gen-go

* Interface definition (.proto) file 
.code grpc/arith/arith.proto

- = 1, = 2 are index tags

* Generate Go stubs for client and server
.play grpc/gen_stubs.sh

- As previously mentioned, this single .proto file can generate stubs for multiple languages, Go, Python, C#, java ...
- Change --go_out to --java_out etc.
* Generated Go stub: types
.code grpc/arith/arith.pb.go /type SumArgs/,/\}/
.code grpc/arith/arith.pb.go /type SumReply/,/\}/

* Go stub: server API
.code grpc/arith/arith.pb.go /type ArithServer/,/\}/
.code grpc/arith/arith.pb.go /RegisterArithServer/,/\}/

* Go stub: client API
.code grpc/arith/arith.pb.go /type ArithClient/,/\}/
.code grpc/arith/arith.pb.go /NewArithClient/,/\}/
.code grpc/arith/arith.pb.go /\*arithClient\) Sum/,/^\}$/

* Server Implementation (1)
.code grpc/server/main.go /010/,/020/

- The go:generate directive allows you to generate grpc/arith/arith.pb.go with the command "go generate"

* Server Implementation (2)
.play grpc/server/main.go /030/,/040/

- The above is mostly standard boiler-plate code. Just update with the appropriate server name (i.e. RegisterArithServer)
- Let's run the gRPC server.

* Client Implementation
.play -edit grpc/client/main.go /010/,/020/
